[ForEach](https://github.com/mejbaulmubin786/Some-Short-Project/blob/main/project3/old/learn/forEach.md)

এটা বোঝাটা জরুরি!  আমাদের মনে হতে পারে যে `btns.forEach()` একবার চলার পরে শেষ হয়ে যায়, তাহলে পরে বাটনে ক্লিক করলে ভেতরের ফাংশনগুলো কীভাবে কাজ করে।

আসলে, `btns.forEach()` ফাংশনটা যখন চলে, তখন এটা `btns` লিস্টের প্রত্যেকটা বাটনের জন্য **একবার করে** ভেতরের ফাংশনটাকে **কল করে**। কিন্তু এই কলের মূল উদ্দেশ্যটা অন্য কিছু।

`btns.forEach(function(btn){ ... });` - এই পুরো ব্লকটার কাজ হলো `btns` লিস্টের **প্রত্যেকটা বাটনের সাথে একটা করে "ক্লিক" করার জন্য নির্দেশ (event listener) যোগ করে দেওয়া**।

বিষয়টা এভাবে ভাবুন:

1.  **প্রস্তুতি পর্ব (btns.forEach চলাকালীন):**
    * `btns` লিস্টে যদি ৩টা বাটন থাকে, `forEach` লুপটা ৩ বার চলবে।
    * প্রথমবার চলার সময়, এটা প্রথম বাটনটাকে (`btn`) ধরে এবং `btn.addEventListener('click', function(e){ console.log(e.currentTarget); });` এই লাইনটা এক্সিকিউট করে। এর মানে হলো - "প্রথম বাটন, যখন কেউ তোমাকে ক্লিক করবে, তখন ভেতরের এই ফাংশনটা চালাবে।"
    * দ্বিতীয়বার চলার সময়, এটা দ্বিতীয় বাটনটাকে ধরে এবং একই কাজ করে - "দ্বিতীয় বাটন, যখন কেউ তোমাকে ক্লিক করবে, তখন ভেতরের এই ফাংশনটা চালাবে।"
    * তৃতীয়বার চলার সময়, এটা তৃতীয় বাটনটার জন্য একই নির্দেশ দেয়।

2.  **ক্লিক করার পর্ব (forEach শেষ হওয়ার পরে):**
    * `btns.forEach()` এর কাজ এখানেই শেষ। এটা একবার চলে তার কাজ সম্পন্ন করে ফেলেছে - প্রত্যেকটা বাটনের সাথে ক্লিক করার জন্য একটা করে "সেন্সর" বসিয়ে দিয়েছে।
    * এখন, যখন কোনো ইউজার (আপনি/আমি) কোনো একটা নির্দিষ্ট বাটনে ক্লিক করে, তখন সেই বাটনের সাথে আগে থেকে বসানো "ক্লিক সেন্সর"টা **detect** করে যে একটা ক্লিক হয়েছে।
    * ক্লিক ডিটেক্ট করার সাথে সাথেই, ঐ নির্দিষ্ট বাটনের জন্য `addEventListener` এর ভেতরে যে ফাংশনটা (`function(e){ console.log(e.currentTarget); }`) **সংরক্ষিত** ছিল, সেটা **তখনই** রান করে।

সহজ ভাষায় বলতে গেলে, `btns.forEach()` লুপটা প্রত্যেকটা বাটনের জন্য **ভবিষ্যতে কী ঘটবে তার একটা নির্দেশনা তৈরি করে রাখে**। যখন সেই ভবিষ্যৎ ঘটনাটা (ক্লিক) বাস্তবে ঘটে, তখন সেই নির্দেশনা অনুযায়ী কাজটা হয়।

এটা অনেকটা এমন: আপনি আপনার তিনজন বন্ধুকে বললেন, "যখনই তোমাদের কেউ ফোন করবে, তোমরা যেন আমার ফোনটা ধরো।" আপনি একবার এই কথাটা বললেন (forEach লুপ), এর মানে এই না যে কথা বলার পরেই কাজ শেষ। যখন আসলেই আপনার বন্ধুরা ফোন করবে (ক্লিক ইভেন্ট), তখন তারা আপনার কথা মতো ফোন ধরবে (ভেতরের ফাংশন রান করবে)।

আরো সহজ করে বললে `forEach` একবার চললেও, এর ভেতরের `addEventListener` প্রত্যেকটা বাটনের সাথে স্থায়ীভাবে "ক্লিক" শোনার জন্য অপেক্ষা করতে থাকে এবং ক্লিক হওয়ার সাথে সাথেই তার ভেতরের কোড এক্সিকিউট করে।





অবশ্যই! একই কাজ আমরা `for` লুপ ব্যবহার করেও করতে পারতাম। `forEach` লুপ মূলত অ্যারে বা NodeList এর প্রতিটি এলিমেন্টের উপর একটি নির্দিষ্ট ফাংশন প্রয়োগ করার জন্য একটি সহজ এবং সংক্ষিপ্ত সিনট্যাক্স সরবরাহ করে। তবে, `for` লুপ ব্যবহার করে আমরা একই ফলাফল অর্জন করতে পারি।

`for` লুপ ব্যবহার করে কোডটি দেখতে কেমন হবে তা নিচে দেওয়া হলো:

```javascript
const btns = document.querySelectorAll('.btn');

for (let i = 0; i < btns.length; i++) {
  const btn = btns[i];
  btn.addEventListener('click', function(e) {
    console.log(e.currentTarget);
  });
}
```

এখানে যা হচ্ছে:

1.  `const btns = document.querySelectorAll('.btn');`: প্রথমে `.btn` ক্লাসের সকল বাটনকে খুঁজে বের করে `btns` নামক NodeList এ রাখা হচ্ছে, যা `forEach` লুপের মতোই।

2.  `for (let i = 0; i < btns.length; i++) { ... }`: এটি একটি সাধারণ `for` লুপ।
    * `let i = 0`: লুপের কাউন্টার `i` এর মান ০ থেকে শুরু হচ্ছে।
    * `i < btns.length`: লুপটি ততক্ষণ পর্যন্ত চলবে যতক্ষণ না `i` এর মান `btns` NodeList এর দৈর্ঘ্যের চেয়ে ছোট থাকে (অর্থাৎ প্রতিটি বাটনের জন্য একবার চলবে)।
    * `i++`: প্রতিটি ইটারেশনের পরে `i` এর মান ১ করে বাড়বে।

3.  `const btn = btns[i];`: লুপের প্রতিটি ইটারেশনে, `btns[i]` ব্যবহার করে NodeList এর বর্তমান ইনডেক্সের বাটন এলিমেন্টটিকে ধরা হচ্ছে এবং `btn` নামক একটি নতুন ভেরিয়েবলে রাখা হচ্ছে।

4.  `btn.addEventListener('click', function(e) { console.log(e.currentTarget); });`: এই লাইনটি `forEach` লুপের ভেতরের লাইনের মতোই কাজ করে। এটি প্রতিটি individual বাটন (`btn`) এর সাথে একটি "click" ইভেন্ট লিসেনার যোগ করে। যখন কোনো বাটনে ক্লিক করা হবে, তখন ভেতরের ফাংশনটি (`function(e){ ... }`) রান করবে এবং ক্লিক করা বাটন এলিমেন্টটিকে কনসোলে প্রিন্ট করবে।

সুতরাং, `forEach` লুপ এবং `for` লুপ উভয়ই এই ক্ষেত্রে একই কাজ করতে পারে। `forEach` সাধারণত কোডকে কিছুটা সংক্ষিপ্ত এবং পঠনযোগ্য করে তোলে যখন আপনি একটি অ্যারে বা NodeList এর প্রতিটি উপাদানের উপর একটি নির্দিষ্ট অপারেশন করতে চান। তবে, `for` লুপ আরও বেশি নিয়ন্ত্রণ প্রদান করে, যেমন আপনি লুপের ফ্লো নিয়ন্ত্রণ করতে পারেন (যেমন `break` বা `continue` ব্যবহার করে)।

এই নির্দিষ্ট পরিস্থিতিতে, আমরা `for` লুপ ব্যবহার করলেও আপনার কোডের কার্যকারিতায় কোনো পরিবর্তন আসবে না। দুটো পদ্ধতিই প্রতিটি বাটনের সাথে ক্লিক ইভেন্ট লিসেনার সঠিকভাবে যুক্ত করবে।




এখন একটি গুরুত্বপূর্ন প্রশ্ন!  btns.forEach একবার চললে তো কাজ শেষ, তাহলে যোগ করা ইভেন্ট লিসেনারগুলো স্থায়ী হয় কীভাবে? এর পেছনের মেকানিজমটা একটু ভালোভাবে বোঝা যাক।

আসলে, যখন আপনি btn.addEventListener('click', function(e){ ... }); কল করেন, তখন ব্রাউজারের ইভেন্ট হ্যান্ডেলিং সিস্টেমে একটা স্থায়ী নিবন্ধন তৈরি হয়। আপনি ঐ নির্দিষ্ট বাটন এলিমেন্টের জন্য ('click' ইভেন্টের জন্য) একটা নির্দিষ্ট ফাংশনকে (আপনার দেওয়া কলব্যাক ফাংশন function(e){ ... }) associate করছেন।


















আসলে, যখন আপনি `btn.addEventListener('click', function(e){ ... });` কল করেন, তখন ব্রাউজারের ইভেন্ট হ্যান্ডেলিং সিস্টেমে একটা **স্থায়ী নিবন্ধন** তৈরি হয়। আপনি ঐ নির্দিষ্ট বাটন এলিমেন্টের জন্য ('click' ইভেন্টের জন্য) একটা নির্দিষ্ট ফাংশনকে (আপনার দেওয়া কলব্যাক ফাংশন `function(e){ ... }`) **associate** করছেন।

বিষয়টা এভাবে কাজ করে:

1.  **ইভেন্ট লিসেনার যোগ করার সময়:**
    * যখন ব্রাউজার আপনার জাভাস্ক্রিপ্ট কোডের এই লাইনটা (`btn.addEventListener(...)`) এক্সিকিউট করে, তখন সে ঐ নির্দিষ্ট বাটন এলিমেন্টের সাথে 'click' ইভেন্টের জন্য আপনার দেওয়া ফাংশনটাকে **মনে রাখে**। এটা কোনো ক্ষণস্থায়ী প্রক্রিয়া নয়। ব্রাউজার তার অভ্যন্তরীণ মেকানিজমের মাধ্যমে এই সম্পর্কটা ধরে রাখে।

2.  **ক্লিক ইভেন্ট ঘটার পরে:**
    * যখন কোনো ইউজার ঐ বাটনে ক্লিক করে, তখন ব্রাউজার সেই ক্লিক ইভেন্টটিকে **ডিটেক্ট** করে।
    * ব্রাউজার তখন ঐ বাটনের সাথে আগে থেকে **নিবন্ধিত** থাকা 'click' ইভেন্টের হ্যান্ডলার ফাংশনটাকে খুঁজে বের করে।
    * খুঁজে পাওয়ার পরে, ব্রাউজার ঐ ফাংশনটাকে **এক্সিকিউট** করে।

এই প্রক্রিয়াটা অনেকটা এমন: আপনি একটি দরজার পাশে একটি ঘণ্টা লাগিয়েছেন এবং সেই ঘণ্টার সাথে আপনার ফোন নম্বরটি লিখে রেখেছেন। আপনি একবারই ঘণ্টা লাগিয়েছেন (addEventListener কল করেছেন)। এর মানে এই না যে একবার বাজার পরেই ঘণ্টাটা চলে যাবে বা আপনার ফোন নম্বর মুছে যাবে। যতক্ষণ দরজাটা সেখানে থাকবে, ততক্ষণ ঘণ্টাও থাকবে এবং আপনার ফোন নম্বরও সেখানে লেখা থাকবে। যখনই কেউ ঘণ্টা বাজাবে, তখনই আপনার ফোন বাজবে।

ঠিক তেমনি, `addEventListener` একবার কল করার মানে হলো আপনি ঐ এলিমেন্টের জন্য ঐ নির্দিষ্ট ইভেন্টের হ্যান্ডলার ফাংশনটিকে স্থায়ীভাবে সেট করে দিয়েছেন (যতক্ষণ না আপনি নিজে থেকে সেটা সরিয়ে দিচ্ছেন - `removeEventListener` ব্যবহার করে)। ব্রাউজার ঐ এলিমেন্টের সাথে ঐ ইভেন্ট এবং তার হ্যান্ডলার ফাংশনের সম্পর্কটা ধরে রাখে এবং যখনই ঐ ইভেন্টটা ঘটে, তখনই হ্যান্ডলার ফাংশনটিকে কল করে।

`forEach` লুপ শুধু প্রত্যেকটা বাটনের জন্য একবার করে `addEventListener` কল করার কাজটি করে। একবার এই কলগুলো হয়ে গেলে, `forEach` এর কাজ শেষ। কিন্তু প্রত্যেকটা বাটনের সাথে ইভেন্ট লিসেনারের যে **সংযোগ** তৈরি হলো, সেটা ব্রাউজারের ইভেন্ট হ্যান্ডেলিং সিস্টেমের মাধ্যমে **স্থায়ীভাবে** থেকে যায় এবং পরবর্তীতে যখনই ক্লিক ইভেন্ট ঘটে, তখনই সেই অনুযায়ী কাজ করে।

আশা করি এই ব্যাখ্যা আপনার কাছে বিষয়টি আরও স্পষ্ট করেছে। এটা বোঝাটা খুবই জরুরি যে `addEventListener` একটি স্থায়ী সম্পর্ক তৈরি করে, যা ইভেন্ট ঘটার জন্য অপেক্ষা করে এবং ঘটলে তার হ্যান্ডলার ফাংশনকে চালায়।

আপনার অনুমান একেবারে সঠিক! **ইভেন্ট লিসেনার** হওয়ার কারণেই এটি স্থায়ী হয়। অন্য কিছু হলে, ব্রাউজার স্বয়ংক্রিয়ভাবে সেই "নির্দেশনা" ধরে রাখত না।

আসুন একটু ভেঙে বলি:

* **ইভেন্ট লিসেনার (addEventListener):** `addEventListener` মেথড বিশেষভাবে ডিজাইন করা হয়েছে ব্রাউজারের ইভেন্ট হ্যান্ডেলিং সিস্টেমের সাথে যোগাযোগ করার জন্য। যখন আপনি `element.addEventListener('event', handlerFunction)` কল করেন, আপনি ব্রাউজারকে বলছেন: "এই নির্দিষ্ট এলিমেন্টের জন্য ('event') যখন এই বিশেষ ঘটনাটি ঘটবে, তখন এই ফাংশনটি ('handlerFunction') চালাও।" ব্রাউজার এই তথ্যটি অভ্যন্তরীণভাবে **নিবন্ধিত** করে রাখে এবং ঘটনাটি ঘটার জন্য অপেক্ষা করে। এই নিবন্ধন স্থায়ী হয় যতক্ষণ না আপনি নিজে `removeEventListener` ব্যবহার করে সরিয়ে দেন অথবা এলিমেন্টটি DOM থেকে সম্পূর্ণরূপে সরিয়ে ফেলা হয়।

* **অন্যান্য সাধারণ ফাংশন কল:** যদি আপনি `btns.forEach` এর ভেতরে অন্য কোনো সাধারণ ফাংশন কল করতেন, যা কোনো ইভেন্টের সাথে সম্পর্কযুক্ত নয়, তাহলে সেই ফাংশনগুলো শুধুমাত্র `forEach` লুপ চলার সময় একবারই এক্সিকিউট হতো এবং তাদের কোনো স্থায়ী প্রভাব থাকত না। ব্রাউজার সেই ফাংশন কলগুলোকে "ভবিষ্যতের জন্য অপেক্ষা করো এবং চালাও" হিসেবে মনে রাখত না।

উদাহরণস্বরূপ, যদি আপনি এমন কিছু করতেন:

```javascript
btns.forEach(function(btn) {
  btn.myCustomFunction = function() {
    console.log("এই ফাংশনটি ক্লিক করলে চলবে না!");
  };
});
```

এই কোডটি প্রতিটি বাটন এলিমেন্টের সাথে `myCustomFunction` নামে একটি প্রোপার্টি যোগ করবে, যেখানে একটি ফাংশন অ্যাসাইন করা আছে। কিন্তু ব্রাউজার স্বয়ংক্রিয়ভাবে জানবে না যে কখন এই `myCustomFunction` কল করতে হবে। এটি কোনো ইভেন্টের সাথে নিবন্ধিত নয়। এই ফাংশনটিকে চালানোর জন্য আপনাকে কোডের অন্য কোনো অংশে স্পষ্টভাবে কল করতে হবে, যেমন `someButton.myCustomFunction()`. এটি `addEventListener` এর মতো ক্লিকে স্বয়ংক্রিয়ভাবে চলবে না।

সুতরাং, **`addEventListener` এর মূল কাজই হলো কোনো নির্দিষ্ট ঘটনার জন্য একটি ফাংশনকে "স্থায়ীভাবে" নিবন্ধন করে রাখা**, যাতে ঐ ঘটনা ঘটলে ফাংশনটি স্বয়ংক্রিয়ভাবে চলতে পারে। অন্য কোনো সাধারণ ফাংশন কল করলে সেই স্থায়ী নিবন্ধন তৈরি হয় না।
